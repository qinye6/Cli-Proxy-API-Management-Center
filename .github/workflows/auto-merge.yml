name: Auto Merge Upstream Repos

on:
  schedule:
    # æ¯å¤© UTC 04:00ï¼ˆåŒ—äº¬æ—¶é—´ 12:00ï¼‰æ‰§è¡Œ
    - cron: '0 4 * * *'
  workflow_dispatch:
    inputs:
      force_merge:
        description: 'å¼ºåˆ¶é‡æ–°åˆå¹¶ï¼ˆå¿½ç•¥ç¼“å­˜çš„ commit SHAï¼‰'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

env:
  # ========== ä¸Šæ¸¸ä»“åº“é…ç½® ==========
  # ä»“åº“1: fatkun ç‰ˆï¼ˆä½œä¸º merge çš„ baseï¼‰
  UPSTREAM_BASE_REPO: "https://github.com/fatkun/Cli-Proxy-API-Management-Center.git"
  UPSTREAM_BASE_BRANCH: "main"
  # ä»“åº“2: kongkongyo ç‰ˆï¼ˆå«ç›‘æŽ§ä¸­å¿ƒç­‰å¢žå¼ºåŠŸèƒ½ï¼Œmerge è¿›æ¥ä»¥ä¿ç•™æ–°å¢žå†…å®¹ï¼‰
  UPSTREAM_FEATURE_REPO: "https://github.com/kongkongyo/Cli-Proxy-API-Management-Center.git"
  UPSTREAM_FEATURE_BRANCH: "main"
  # æœ¬ä»“åº“çš„ç›®æ ‡åˆ†æ”¯
  TARGET_BRANCH: "main"

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  merge-upstream:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout this repository
        uses: actions/checkout@v4
        with:
          ref: ${{ env.TARGET_BRANCH }}
          fetch-depth: 0
          # ä½¿ç”¨ PAT ä»¥èŽ·å¾—æŽ¨é€ workflow æ–‡ä»¶çš„æƒé™
          # å¦‚æžœä¸éœ€è¦æŽ¨é€ workflow æ–‡ä»¶ï¼Œå¯æ”¹ä¸º ${{ secrets.GITHUB_TOKEN }}
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remotes
        run: |
          git remote add upstream-base "$UPSTREAM_BASE_REPO" 2>/dev/null || true
          git remote add upstream-feature "$UPSTREAM_FEATURE_REPO" 2>/dev/null || true

      - name: Fetch upstream branches
        run: |
          echo "::group::Fetching upstream-base (fatkun)"
          git fetch upstream-base "$UPSTREAM_BASE_BRANCH" --no-tags
          echo "::endgroup::"

          echo "::group::Fetching upstream-feature (kongkongyo)"
          git fetch upstream-feature "$UPSTREAM_FEATURE_BRANCH" --no-tags
          echo "::endgroup::"

      - name: Check for updates
        id: check
        run: |
          BASE_SHA=$(git rev-parse "upstream-base/$UPSTREAM_BASE_BRANCH")
          FEATURE_SHA=$(git rev-parse "upstream-feature/$UPSTREAM_FEATURE_BRANCH")

          echo "base_sha=$BASE_SHA" >> "$GITHUB_OUTPUT"
          echo "feature_sha=$FEATURE_SHA" >> "$GITHUB_OUTPUT"

          echo "ðŸ“Œ Base upstream (fatkun) SHA:    $BASE_SHA"
          echo "ðŸ“Œ Feature upstream (kongkongyo) SHA: $FEATURE_SHA"

          # è¯»å–ä¸Šæ¬¡æˆåŠŸåˆå¹¶æ—¶è®°å½•çš„ SHA
          LAST_BASE=""
          LAST_FEATURE=""
          if [ -f ".merge-state/last-base-sha" ]; then
            LAST_BASE=$(cat ".merge-state/last-base-sha")
          fi
          if [ -f ".merge-state/last-feature-sha" ]; then
            LAST_FEATURE=$(cat ".merge-state/last-feature-sha")
          fi

          echo "ðŸ“Œ Last merged base SHA:    ${LAST_BASE:-none}"
          echo "ðŸ“Œ Last merged feature SHA: ${LAST_FEATURE:-none}"

          FORCE="${{ github.event.inputs.force_merge || 'false' }}"

          if [ "$FORCE" = "true" ]; then
            echo "âš¡ Force merge requested, skipping cache check"
            echo "needs_merge=true" >> "$GITHUB_OUTPUT"
          elif [ "$BASE_SHA" = "$LAST_BASE" ] && [ "$FEATURE_SHA" = "$LAST_FEATURE" ]; then
            echo "âœ… No changes detected in either upstream. Skipping merge."
            echo "needs_merge=false" >> "$GITHUB_OUTPUT"
          else
            echo "ðŸ”„ Changes detected, proceeding with merge."
            echo "needs_merge=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Perform merge
        id: merge
        if: steps.check.outputs.needs_merge == 'true'
        run: |
          set +e  # Don't exit on error

          echo "::group::Step 1 - Reset to base upstream (fatkun)"
          # åˆ›å»ºä¸´æ—¶åˆå¹¶åˆ†æ”¯ï¼Œä»¥ fatkun ç‰ˆä¸ºåŸºç¡€
          MERGE_BRANCH="auto-merge/$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$MERGE_BRANCH" "upstream-base/$UPSTREAM_BASE_BRANCH"
          echo "merge_branch=$MERGE_BRANCH" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"

          echo "::group::Step 2 - Merge feature upstream (kongkongyo)"
          # å°† kongkongyo ç‰ˆ merge è¿›æ¥ï¼Œè¿™æ ·å®ƒçš„æ–°å¢žå†…å®¹ï¼ˆç›‘æŽ§ä¸­å¿ƒç­‰ï¼‰ä¼šè¢«ä¿ç•™
          MERGE_OUTPUT=$(git merge "upstream-feature/$UPSTREAM_FEATURE_BRANCH" \
            --no-edit \
            --allow-unrelated-histories \
            -m "chore: auto-merge fatkun + kongkongyo [$(date +%Y-%m-%d)]" 2>&1)
          MERGE_EXIT=$?
          echo "$MERGE_OUTPUT"
          echo "::endgroup::"

          if [ $MERGE_EXIT -eq 0 ]; then
            echo "âœ… Merge succeeded without conflicts!"
            echo "merge_status=success" >> "$GITHUB_OUTPUT"
            echo "conflict_files=" >> "$GITHUB_OUTPUT"
          else
            echo "âš ï¸ Merge has conflicts!"
            echo "merge_status=conflict" >> "$GITHUB_OUTPUT"

            # èŽ·å–å†²çªæ–‡ä»¶åˆ—è¡¨
            CONFLICT_FILES=$(git diff --name-only --diff-filter=U | head -50)
            echo "Conflicting files:"
            echo "$CONFLICT_FILES"

            # å­˜å‚¨å†²çªæ–‡ä»¶åˆ—è¡¨ï¼ˆè½¬ä¹‰æ¢è¡Œï¼‰
            CONFLICT_FILES_ESCAPED=$(echo "$CONFLICT_FILES" | tr '\n' '|')
            echo "conflict_files=$CONFLICT_FILES_ESCAPED" >> "$GITHUB_OUTPUT"

            # ä¸­æ­¢åˆå¹¶ï¼Œä¸ºåŽç»­åˆ›å»º PR åšå‡†å¤‡
            git merge --abort
          fi

      # ========== æž„å»º management.htmlï¼ˆåœ¨åˆå¹¶åˆ†æ”¯ä¸Šæ‰§è¡Œï¼‰ ==========
      - name: Setup Node.js
        if: steps.merge.outputs.merge_status == 'success'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        if: steps.merge.outputs.merge_status == 'success'
        run: npm ci

      - name: Build management.html
        id: build
        if: steps.merge.outputs.merge_status == 'success'
        run: |
          npm run build
          if [ -f dist/index.html ]; then
            mv dist/index.html dist/management.html
            # å°†æž„å»ºäº§ç‰©å¤åˆ¶åˆ°ä¸´æ—¶ç›®å½•ï¼Œä¾› push åŽä¸Šä¼  Release
            mkdir -p /tmp/build-artifacts
            cp dist/management.html /tmp/build-artifacts/
            echo "build_success=true" >> "$GITHUB_OUTPUT"
            echo "âœ… Build successful! management.html generated."
            ls -lh dist/management.html
          else
            echo "build_success=false" >> "$GITHUB_OUTPUT"
            echo "âŒ Build failed: dist/index.html not found"
          fi

      # ========== æŽ¨é€åˆå¹¶ç»“æžœï¼ˆä¿ç•™è‡ªå®šä¹‰æ–‡ä»¶ï¼‰ ==========
      - name: Push merged result
        if: steps.merge.outputs.merge_status == 'success'
        run: |
          MERGE_BRANCH="${{ steps.merge.outputs.merge_branch }}"

          # ---------- å¤‡ä»½æœ¬ä»“åº“çš„è‡ªå®šä¹‰æ–‡ä»¶ ----------
          # è¿™äº›æ–‡ä»¶ä¸å­˜åœ¨äºŽä»»ä½•ä¸Šæ¸¸ä»“åº“ä¸­ï¼Œgit reset --hard ä¼šåˆ é™¤å®ƒä»¬
          echo "::group::Backup custom files"
          BACKUP_DIR="/tmp/custom-files-backup"
          mkdir -p "$BACKUP_DIR"

          # åˆ‡æ¢å›žç›®æ ‡åˆ†æ”¯ï¼Œè¯»å–è‡ªå®šä¹‰æ–‡ä»¶
          git checkout "$TARGET_BRANCH"

          # å¤‡ä»½ .github/workflows/
          if [ -d ".github/workflows" ]; then
            mkdir -p "$BACKUP_DIR/.github/workflows"
            cp -r .github/workflows/* "$BACKUP_DIR/.github/workflows/"
            echo "  âœ… Backed up .github/workflows/"
          fi

          # å¤‡ä»½ scripts/
          if [ -d "scripts" ]; then
            mkdir -p "$BACKUP_DIR/scripts"
            cp -r scripts/* "$BACKUP_DIR/scripts/"
            echo "  âœ… Backed up scripts/"
          fi

          # å¤‡ä»½ .merge-state/
          if [ -d ".merge-state" ]; then
            mkdir -p "$BACKUP_DIR/.merge-state"
            cp -r .merge-state/* "$BACKUP_DIR/.merge-state/"
            echo "  âœ… Backed up .merge-state/"
          fi

          echo "::endgroup::"

          # ---------- é‡ç½®åˆ°åˆå¹¶åˆ†æ”¯ ----------
          echo "::group::Reset to merge branch"
          git reset --hard "$MERGE_BRANCH"
          echo "::endgroup::"

          # ---------- æ¢å¤è‡ªå®šä¹‰æ–‡ä»¶ ----------
          echo "::group::Restore custom files"

          # æ¢å¤ .github/workflows/
          if [ -d "$BACKUP_DIR/.github/workflows" ]; then
            mkdir -p .github/workflows
            cp -r "$BACKUP_DIR/.github/workflows/"* .github/workflows/
            echo "  âœ… Restored .github/workflows/"
          fi

          # æ¢å¤ scripts/
          if [ -d "$BACKUP_DIR/scripts" ]; then
            mkdir -p scripts
            cp -r "$BACKUP_DIR/scripts/"* scripts/
            echo "  âœ… Restored scripts/"
          fi

          # æ¢å¤å¹¶æ›´æ–° .merge-state/
          mkdir -p .merge-state
          echo "${{ steps.check.outputs.base_sha }}" > .merge-state/last-base-sha
          echo "${{ steps.check.outputs.feature_sha }}" > .merge-state/last-feature-sha
          echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > .merge-state/last-merge-time
          echo "  âœ… Updated .merge-state/"

          echo "::endgroup::"

          # ---------- æäº¤å¹¶æŽ¨é€ ----------
          git add .github/ scripts/ .merge-state/
          git commit --amend --no-edit

          git push origin "$TARGET_BRANCH" --force-with-lease
          echo "âœ… Successfully pushed merged code to $TARGET_BRANCH (custom files preserved)"

      # ========== åˆ›å»º Release ==========
      - name: Create auto-merge Release
        if: steps.build.outputs.build_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const today = new Date().toISOString().split('T')[0];
            const baseSha = '${{ steps.check.outputs.base_sha }}'.substring(0, 8);
            const featureSha = '${{ steps.check.outputs.feature_sha }}'.substring(0, 8);
            const tagName = `auto-merge-${today}`;

            // åˆ é™¤å·²å­˜åœ¨çš„åŒå tag å’Œ releaseï¼ˆå¦‚æžœæœ‰ï¼‰
            try {
              const { data: existingRelease } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName,
              });
              if (existingRelease) {
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: existingRelease.id,
                });
                core.info(`Deleted existing release: ${tagName}`);
              }
            } catch (e) {
              // Release ä¸å­˜åœ¨ï¼Œæ­£å¸¸
            }

            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tagName}`,
              });
              core.info(`Deleted existing tag: ${tagName}`);
            } catch (e) {
              // Tag ä¸å­˜åœ¨ï¼Œæ­£å¸¸
            }

            // åŒæ—¶æ›´æ–° latest-auto-merge tag
            const latestTag = 'latest-auto-merge';
            try {
              const { data: latestRelease } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: latestTag,
              });
              if (latestRelease) {
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: latestRelease.id,
                });
              }
            } catch (e) {}

            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${latestTag}`,
              });
            } catch (e) {}

            const body = `## ðŸ”€ è‡ªåŠ¨åˆå¹¶æž„å»º (${today})

            æ­¤ Release ç”± auto-merge workflow è‡ªåŠ¨ç”Ÿæˆã€‚

            ### ä¸Šæ¸¸ç‰ˆæœ¬
            - **fatkun ç‰ˆ**: \`${baseSha}\`
            - **kongkongyo ç‰ˆ**: \`${featureSha}\`

            ### ä½¿ç”¨æ–¹æ³•
            1. ä¸‹è½½ \`management.html\`
            2. å°†å…¶æ”¾å…¥ CLI Proxy API çš„å¯¹åº”ç›®å½•ä¸­æ›¿æ¢åŽŸæ–‡ä»¶
            3. é‡å¯æœåŠ¡å³å¯

            ---
            *æ­¤ Release ç”± GitHub Actions è‡ªåŠ¨åˆ›å»º*`;

            // åˆ›å»ºæ—¥æœŸç‰ˆ Release
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `Auto Merge Build ${today}`,
              body: body,
              draft: false,
              prerelease: false,
              target_commitish: process.env.TARGET_BRANCH,
            });

            // ä»Žä¸´æ—¶ç›®å½•è¯»å–æž„å»ºäº§ç‰©ä¸Šä¼ 
            const fileContent = fs.readFileSync('/tmp/build-artifacts/management.html');
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              name: 'management.html',
              data: fileContent,
            });

            core.info(`Created release: ${tagName} with management.html`);

            // åˆ›å»º latest-auto-merge Releaseï¼ˆæ–¹ä¾¿ç›´æŽ¥ä¸‹è½½æœ€æ–°ç‰ˆï¼‰
            const { data: latestRel } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: latestTag,
              name: `Latest Auto Merge Build`,
              body: body,
              draft: false,
              prerelease: false,
              target_commitish: process.env.TARGET_BRANCH,
            });

            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: latestRel.id,
              name: 'management.html',
              data: fileContent,
            });

            core.info(`Created latest release: ${latestTag} with management.html`);

      # ========== å†²çªå¤„ç†ï¼šåˆ›å»º PR ==========
      - name: Create conflict PR
        if: steps.merge.outputs.merge_status == 'conflict'
        uses: actions/github-script@v7
        with:
          script: |
            const conflictFiles = '${{ steps.merge.outputs.conflict_files }}'
              .split('|')
              .filter(f => f.trim())
              .map(f => `- \`${f.trim()}\``)
              .join('\n');

            const baseSha = '${{ steps.check.outputs.base_sha }}'.substring(0, 8);
            const featureSha = '${{ steps.check.outputs.feature_sha }}'.substring(0, 8);
            const today = new Date().toISOString().split('T')[0];

            // æ£€æŸ¥æ˜¯å¦å·²æœ‰æœªå…³é—­çš„å†²çª PR
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:auto-merge/conflict`,
            });

            if (existingPRs.length > 0) {
              // æ›´æ–°çŽ°æœ‰ PR çš„ body
              const pr = existingPRs[0];
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                body: `## âš ï¸ è‡ªåŠ¨åˆå¹¶å†²çª (${today})

            ä¸Šæ¸¸ä»“åº“è‡ªåŠ¨åˆå¹¶æ—¶å‘çŽ°å†²çªï¼Œéœ€è¦äººå·¥è§£å†³ã€‚

            ### ä¸Šæ¸¸ç‰ˆæœ¬
            - **fatkun ç‰ˆ** (upstream-base): \`${baseSha}\`
            - **kongkongyo ç‰ˆ** (upstream-feature): \`${featureSha}\`

            ### å†²çªæ–‡ä»¶
            ${conflictFiles}

            ### è§£å†³æ–¹æ³•
            1. æ‹‰å–æœ¬åˆ†æ”¯åˆ°æœ¬åœ°
            2. æ‰§è¡Œ \`git merge origin/${process.env.TARGET_BRANCH}\`
            3. è§£å†³æ‰€æœ‰å†²çª
            4. æäº¤å¹¶æŽ¨é€
            5. åˆå¹¶æ­¤ PR

            ---
            *æ­¤ PR ç”± GitHub Actions è‡ªåŠ¨åˆ›å»º*`,
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `ðŸ”„ **æ›´æ–° (${today})**: å†²çªä»ç„¶å­˜åœ¨ã€‚\n\nfatkun ç‰ˆ: \`${baseSha}\`\nkongkongyo ç‰ˆ: \`${featureSha}\`\n\nå†²çªæ–‡ä»¶:\n${conflictFiles}`,
              });

              core.info(`Updated existing conflict PR #${pr.number}`);
            } else {
              // åˆ›å»ºå†²çªåˆ†æ”¯
              const { execSync } = require('child_process');

              // åŸºäºŽ fatkun ç‰ˆåˆ›å»ºåˆ†æ”¯ï¼Œç„¶åŽå¸¦å†²çªæ ‡è®°åˆå¹¶
              execSync(`git checkout -B auto-merge/conflict upstream-base/${process.env.UPSTREAM_BASE_BRANCH}`, { stdio: 'inherit' });
              execSync(`git merge upstream-feature/${process.env.UPSTREAM_FEATURE_BRANCH} --no-commit --no-ff || true`, { stdio: 'inherit' });

              // å°†æ‰€æœ‰å†²çªæ–‡ä»¶æ ‡è®°ä¸º"ä¸¤è¾¹éƒ½ä¿ç•™"ç„¶åŽæäº¤
              execSync('git add -A', { stdio: 'inherit' });
              execSync(`git commit -m "chore: merge with conflicts for manual resolution [${today}]" --allow-empty`, { stdio: 'inherit' });
              execSync('git push origin auto-merge/conflict --force', { stdio: 'inherit' });

              // åˆ›å»º PR
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `âš ï¸ è‡ªåŠ¨åˆå¹¶å†²çªéœ€è¦äººå·¥å¤„ç† [${today}]`,
                head: 'auto-merge/conflict',
                base: process.env.TARGET_BRANCH,
                body: `## âš ï¸ è‡ªåŠ¨åˆå¹¶å†²çª

            ä¸Šæ¸¸ä»“åº“è‡ªåŠ¨åˆå¹¶æ—¶å‘çŽ°å†²çªï¼Œéœ€è¦äººå·¥è§£å†³ã€‚

            ### ä¸Šæ¸¸ç‰ˆæœ¬
            - **fatkun ç‰ˆ** (upstream-base): \`${baseSha}\`
            - **kongkongyo ç‰ˆ** (upstream-feature): \`${featureSha}\`

            ### å†²çªæ–‡ä»¶
            ${conflictFiles}

            ### è§£å†³æ–¹æ³•
            1. æ‹‰å–æœ¬åˆ†æ”¯åˆ°æœ¬åœ°ï¼š
               \`\`\`bash
               git fetch origin auto-merge/conflict
               git checkout auto-merge/conflict
               \`\`\`
            2. é‡æ–°æ‰§è¡Œåˆå¹¶å¹¶è§£å†³å†²çªï¼š
               \`\`\`bash
               git reset --hard upstream-base/${process.env.UPSTREAM_BASE_BRANCH}
               git merge upstream-feature/${process.env.UPSTREAM_FEATURE_BRANCH}
               # è§£å†³æ‰€æœ‰å†²çªæ–‡ä»¶
               git add .
               git commit
               \`\`\`
            3. æŽ¨é€å¹¶åˆå¹¶æ­¤ PR

            ---
            *æ­¤ PR ç”± GitHub Actions è‡ªåŠ¨åˆ›å»º*`,
              });

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['auto-merge', 'conflict', 'needs-manual-review'],
              });

              core.info(`Created conflict PR #${pr.number}`);
            }

      # ========== è¿è¡Œæ€»ç»“ ==========
      - name: Summary
        if: always()
        run: |
          echo "## Auto-Merge Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ steps.check.outputs.needs_merge }}" = "false" ]; then
            echo "âœ… **No updates detected** â€” skipped merge." >> "$GITHUB_STEP_SUMMARY"
          elif [ "${{ steps.merge.outputs.merge_status }}" = "success" ]; then
            echo "âœ… **Merge successful** â€” pushed to \`$TARGET_BRANCH\`" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "- fatkun: \`${{ steps.check.outputs.base_sha }}\`" >> "$GITHUB_STEP_SUMMARY"
            echo "- kongkongyo: \`${{ steps.check.outputs.feature_sha }}\`" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            if [ "${{ steps.build.outputs.build_success }}" = "true" ]; then
              echo "ðŸ“¦ **Build successful** â€” \`management.html\` uploaded to Release" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "âš ï¸ **Build failed** â€” check logs for details" >> "$GITHUB_STEP_SUMMARY"
            fi
          elif [ "${{ steps.merge.outputs.merge_status }}" = "conflict" ]; then
            echo "âš ï¸ **Merge conflict** â€” PR created for manual resolution." >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "Conflicting files:" >> "$GITHUB_STEP_SUMMARY"
            echo '${{ steps.merge.outputs.conflict_files }}' | tr '|' '\n' | while read -r f; do
              [ -n "$f" ] && echo "- \`$f\`" >> "$GITHUB_STEP_SUMMARY"
            done
          else
            echo "âŒ **Merge failed** â€” check the logs above." >> "$GITHUB_STEP_SUMMARY"
          fi
